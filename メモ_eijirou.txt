ゲームシステム確認事項

・可能な指手を全て出力して、駒の動きの正当性をざっと確認する。
・成った駒の動きを確認する。
・飛車や角の動きを確認する。
・金や王が成れないことを確認する。
・歩が成れるときに必ず成ることを確認する。
・銀、飛車、角が成っても成らなくてもよいことを確認する。
・敵陣から離れるときにも成れることを確認する。

・二歩を打てないことを確認する。
・敵陣に歩を打てないことを確認する。
・打ち歩詰めができないことを確認する。
・王手放置ができないことを確認する。
・駒を動かして自分の王が王手状態にできないことを確認する。

・ステイルメイトが詰みとみなされることを確認する。（ステイルメイトの場合は反則手を指す前に負けにするという理解で合ってる？）
・詰みのときにゲームが終了することを確認する。
・反則手を指したときにゲームが終了することを確認する。

・打ち歩詰めと連続王手千日手が絡んだときは打ち歩詰めとみなすことを確認する。（多分そうなっていない。どうしよう。）



12/14に話したいこと
・進捗状況の確認
・実行およびバグについて
・最後の審判について
・ランダム遷移について
    ・さまざまな棋譜を大量に作成できる。
    ・棋譜を作っておけば、モデルの学習に使えるかも。
・モンテカルロ法について
    ・弱そうだが、もしかしたら強い。
    ・「半分の時間が経ったら、悪そうな候補を半分削除する」みたいな工夫をするといいかも。
    ・ループにはまらない工夫（例えば150手制限）が必要かも。
・探索について
    ・Mini-Max法（Nega-Max法）について
    ・αカット、βカットによる枝刈りについて
   　　・その他多くの手法がある。
    ・評価関数による枝刈りについて
・評価関数について
    ・駒得評価関数は不十分な気がする。
    ・KPP(King Piece Piece)などが知られているが、パラメータの数が多いらしい。
    ・Neural Networkもよく使われているが、入力が盤面ではなく特徴量（例えばKPP）であることも。
    ・個人的にはNNを作りたいが、まともな評価関数を作れる自信はない。
・次の担当について


/*
main関数の一部を書きました。
色々と雑に書いています。

先手番と後手番で4つに場合分けをしているのはわざとです。
*/

#define MAX_TURN 150
#define FIRST 1
#define SECOND 0


Action get_user_action(int turn){
    //scanf
    //Action action = string_to_action
    if (turn % 2 == 0)
        // 後手番のとき
        reverse_action(action);
    return action;
}

void display_action(Action action, int turn){
    if (turn % 2 == 0)
        // 後手番のとき
        reverse_action(action);
    printf("%s", action_to_string(action));
}


int main(void){

    // 実行時引数の処理
    int first_is_user = 1;
    int second_is_user = 0;



    Board board = create_board();
    print_board_for_debug(&board);

    //history = ; 盤面の履歴
    int winner = -1;

    for (int turn = 1; turn <= MAX_TURN; turn++){
        Action action;

        if (turn % 2){
            // 先手番
            if (first_is_user)
                action = get_user_action(turn);
            else{
                action = get_ai_action(&board, history, turn);
                display_action(action);
            }
        }
        else{
            // 後手番
            if (second_is_user)
                action = get_user_action(turn);
            else{
                action = get_ai_action(&board, history, turn);
                display_action(action, turn);
            }
        }

        winner = move_piece(&board, action, history, turn);
        print_board_for_debug(&board);

        if (winner != -1)
            break;
        
        reverse_board(&board);
    }

    // 出力
}
